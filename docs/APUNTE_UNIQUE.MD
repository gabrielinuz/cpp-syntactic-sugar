# ğŸ“ APUNTE: Â¿Por quÃ© no copiamos `unique_ptr`, y cuÃ¡ndo usar `&`, `&&`, o `*` con smart pointers?

> ğŸ“ *Material didÃ¡ctico para estudiantes de Tecnicatura Superior en AnÃ¡lisis de Sistemas*  
> âœ¦ Por el TecnÃ³logo Educativo â€” para que entiendas no solo **cÃ³mo**, sino **por quÃ©** âœ¦

---

## ğŸ”‘ 1. El principio de *ownership* (posesiÃ³n)

En C++, la memoria no se gestiona "mÃ¡gicamente".  
Cada recurso (como un objeto en el *heap*) debe tener **un Ãºnico responsable** de liberarlo.

| Smart pointer | SemÃ¡ntica | Â¿Se puede copiar? |
|---------------|-----------|-------------------|
| `std::shared_ptr<T>` | **Varios** comparten la responsabilidad (cuenta referencias). | âœ… SÃ­ (`refcount++`) |
| `std::unique_ptr<T>` | **Solo uno** es responsable. *Exclusividad garantizada*. | âŒ **No** (constructor de copia borrado) |

### Ejemplo: `unique_ptr` no se copia
```cpp
auto a = std::make_unique<int>(42);
auto b = a;               // âŒ ERROR de compilaciÃ³n
auto b = std::move(a);    // âœ… OK: "a" entrega la responsabilidad a "b"
// Ahora: a == nullptr, b posee el 42.